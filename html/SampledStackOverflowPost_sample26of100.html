<p>Your approach looks fine, just needlessly complicated.  I would do it like this:</p>

<pre><code>use strict;
use warnings;

# usage: randseq.pl [fraction] &lt; input.fasta &gt; output.fasta
my $fraction = (@ARGV ? shift : 0.6321);

# Collect input lines into an array of sequences:
my @sequences;
while (&lt;&gt;) {
    # A leading &gt; starts a new sequence. (The "\" is only there to
    # avoid confusing the Stack Overflow syntax highlighting.)
    push @sequences, [] if /^\&gt;/;
    push @{ $sequences[-1] }, $_;
}

# Calculate how many sequences we want:
my $n = @sequences;
my $k = int( $n * $fraction + 0.5 );
warn "Selecting $k out of $n sequences (", 100 * $k / $n, "%).\n";

# Do a partial Fisher-Yates shuffle to select $k random sequences out of $n:
foreach my $i (0 .. $k-1) {
    my $j = $i + int rand($n-$i);
    @sequences[$i,$j] = @sequences[$j,$i];
}

# Print the output:
print @$_ for @sequences[0 .. $k-1];
</code></pre>

<p>Note that this code reads the entire contents of the input file into memory.  If the input file is too large for that, and you only want a small subset of it, it's possible to use <a href="http://en.wikipedia.org/wiki/Reservoir_sampling" rel="nofollow">reservoir sampling</a> to select <em>k</em> random sequences out of an arbitrarily large collection of them without holding more:</p>

<pre><code>use strict;
use warnings;

my $k = (@ARGV ? shift : 632);  # sample size: need to know this in advance

# Use reservoir sampling to select $k random sequences:
my @samples;
my $n = 0;  # total number of sequences read
my $i;      # index of current sequence
while (&lt;&gt;) {
    if (/^\&gt;/) {
        # Select a random sequence from 0 to $n-1 to replace:
        $i = int rand ++$n;
        # Save all samples until we've accumulated $k of them:
        $samples[$n-1] = $samples[$i] if $n &lt;= $k;
        # Only actually store the new sequence if it's one of the $k first ones:
        $samples[$i] = [] if $i &lt; $k;
    }
    push @{ $samples[$i] }, $_ if $i &lt; $k;
}

warn "Only read $n &lt; $k sequences, selected all.\n" if $n &lt; $k;
warn "Selected $k out of $n sequences (", 100 * $k / $n, "%).\n" if $n &gt;= $k;

# Print sampled sequences:
print @$_ for @samples;
</code></pre>

<p>However, if you really want a certain <em>fraction</em> of the input sequences, you'll need to first count them in a separate pass over the file.</p>

<p>Both of the programs above also uniformly shuffle the sampled sequences as a side effect.  (In fact, I deliberately tweaked the reservoir sampling algorithm to make the shuffle uniform for all values of <em>n</em> and <em>k</em>.)  If you don't want that, you can always sort the sequences according to whatever criterion you prefer before printing them.</p>

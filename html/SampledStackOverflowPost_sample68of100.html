Answered posted on: 2012-03-04 23:02:41+00:00
<a<p>You want the most efficient way to store a reference to an object in an object?</p>

<p>The most efficient way is a pointer.  It is likely 4 or 8 bytes, and likely doesn't affect the alignment of the next item in the struct, so is therefore fine.</p>

<p>You can save bytes by having numbers that look up owner objects, but this is likely actually not saving real bytes in the struct allocation, its just introducing padding.</p>

<p>Setting a pointer takes a memory word write.  The destination is likely adjacent to other writes you are doing during initialization; its unlikely to impact performance even in a tight loop.</p>

<p>An alternative to using <code>stl::list</code> is to put the list nodes themselves inside the data-structure.</p>

<p>This is common in high-performance environments e.g. kernels.  Here's a description of <a href="http://isis.poly.edu/kulesh/stuff/src/klist/" rel="nofollow">the Linux kernel one</a>.</p>

<p>By placing the next (and possibly previous) pointer (or ***<a href="http://en.wikipedia.org/wiki/XOR_linked_list" rel="nofollow">XORing them</a> to save space) inside the struct, no separate memory allocation is required.</p>

<p>This means that a object in the list can only ever be in one list at a time, but your <code>to</code> field means this anyway so this does not constrain you.</p>

<p>You can have a convention that the head is actually the owning object; this obviously takes O(n) to discover but perhaps you need to discover the <code>to</code> only occasionally?</p>

<p>So to summarize:</p>

<ul>
<li>you can save memory by not having an <code>stl::list</code> at all, but rather just have <code>next</code> (and <code>prev</code>, or perhaps XOR them) in the node itself</li>
<li>you can use this space you save to add a <code>to</code> field explicitly</li>
<li>or you can have a convention where the head of the list is actually the owner</li>
</u

Answered posted on: 2015-01-14 05:35:10+00:00
<a<p>As per the formatting of your question, its too hard to understand the problem, but at first look, it seems, you're passing non-malloced pointers to <code>free()</code> . The result is ***<a href="https://en.wikipedia.org/wiki/Undefined_behavior" rel="nofollow">undefined behaviour</a>.</p>

<p>Please remove</p>

<pre><code>free(&amp;b-&gt;value_w);
free(&amp;m-&gt;from_x);
</code></pre>

<p>and the remaining compile-time allocated variable addresses.</p>

<p>As per the rules, <code>free()</code>-ing is only allowed [rather, required] for dynamically allocated memory. OTOH, Compile-time memory need not to be freed explicitly from your program.</p>

<p><em>Related Reading:</em> According to Chapter 7.20.3.2, <code>C99</code> standard, paragraph 2</p>

<blockquote>
  <p>The free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to free or realloc, the behavior is undefined.</p>
</blockquote>

<p>Also, you should refer to the <a href="http://linux.die.net/man/3/free" rel="nofollow">manual page</a> for <code>free()</code>.</p>

<p>Other than this, for the <em>leak</em> in your case, you're freeing the <code>b-&gt;parent</code> but did not free the nested allocated memory for <code>b-&gt;parent</code>. Again, you did not free <code>children_w</code> and <code>children_b</code> at all. They all need to be taken care properly.</

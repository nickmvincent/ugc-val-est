<p>Yes, it is how it works. This is known as accumulator argument technique for writing <a href="http://en.wikipedia.org/wiki/Tail_recursion" rel="nofollow">tail recursive</a> functions. It helps to visualize its operation with some example, e.g.</p>

<pre><code>reverse [1,2,3,4] 
  = rev  NIL  [1,2,3,4]
  = rev  [1]    [2,3,4]
  = rev  [2,1]    [3,4]
  = rev  [3,2,1]    [4]
  = rev  [4,3,2,1]  NIL
  = [4,3,2,1]
</code></pre>

<p>It seems your code comes from an oldish (1st ed. 1982, ISBN 0-471-08755-6) <a href="http://rads.stackoverflow.com/amzn/click/0471104264" rel="nofollow">textbook</a>. In today's Scheme e.g. it's written almost the same, but without the extra parentheses (with few constants redefined):</p>

<pre><code>(define reverse (lambda (l) .... ))
(define rev (lambda (out in) .... ))

(define NIL '())
(define T    #t)
(define NULL null?)
</code></pre>

<p>The so-called "lambda forms", i.e. forms (well-formed, parenthesized snippets of code) starting with <code>lambda</code> "keyword", signify anonymous functions. The list after the symbol <code>lambda</code> specifies formal parameters of such function. <code>define</code> allows us to name the function created by a lambda-form. That way we can  make recursive call to it inside its definition, using its name. </p>

<p>This recursive call is in <a href="http://en.wikipedia.org/wiki/Tail_call" rel="nofollow">tail position</a>, so the operation of this function is equivalent to a loop (achieved by reusing the <a href="http://en.wikipedia.org/wiki/Stack_frame#Structure" rel="nofollow">stack frame</a> for the function call, resetting the formal parameters on each iteration  which thus serve as loop variables).</p>

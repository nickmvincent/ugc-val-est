<p>You quote the somewhat dated <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW3" rel="nofollow">Blocks Programming Topics</a>, which says:</p>

<blockquote>
  <p>To override this behavior for a particular object variable, you can mark it with the <code>__block</code> storage type modifier.</p>
</blockquote>

<p>That document dates back to the days of manual reference counting, back before <a href="https://en.m.wikipedia.org/wiki/Automatic_Reference_Counting" rel="nofollow">ARC</a>. In manual reference counting code you could use <code>__block</code> to avoid establishing a <a href="https://en.wikipedia.org/wiki/Weak_reference" rel="nofollow">strong reference</a> to objects referenced inside the block. </p>

<p>But this behavior has changed with ARC, as outlined in <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" rel="nofollow">Transitioning to ARC Release Notes</a>. We now use <code>weak</code> in those cases where we don't want to establish strong references to the objects referenced in the block. (You can use <code>unsafe_unretained</code> in special cases where you know the resulting dangling pointer isn't a problem.)</p>

<p>So, go ahead and use <code>__block</code> when dealing with fundamental types that you want to mutate inside the block. But when dealing with objects in blocks under ARC, the <code>__block</code> qualifier generally doesn't enter the discussion. The question is simply whether you want a strong reference or a weak one (or an unsafe, unretained one). And that's largely dictated by the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" rel="nofollow">object graph</a> of your app, namely (a) whether you need weak/unretained reference to prevent strong reference cycle; or (b) you don't want want some asynchronously executing block to unnecessarily prolong the life of some object referenced in the block. Neither of those situations would appear to be the case here.</p>

<p>Here is some code I use to perform FFT in iOS using Accelerate Framework, which makes it quite fast.</p>

<pre><code>//keep all internal stuff inside this struct
    typedef struct FFTHelperRef {
        FFTSetup fftSetup; // Accelerate opaque type that contains setup information for a given FFT transform.
        COMPLEX_SPLIT complexA; // Accelerate type for complex number
        Float32 *outFFTData; // Your fft output data
        Float32 *invertedCheckData; // This thing is to verify correctness of output. Compare it with input.
    } FFTHelperRef;
</code></pre>

<p>//first - initialize your FFTHelperRef with this function.</p>

<pre><code>FFTHelperRef * FFTHelperCreate(long numberOfSamples) {

    FFTHelperRef *helperRef = (FFTHelperRef*) malloc(sizeof(FFTHelperRef));
    vDSP_Length log2n = log2f(numberOfSamples);    
    helperRef-&gt;fftSetup = vDSP_create_fftsetup(log2n, FFT_RADIX2);
    int nOver2 = numberOfSamples/2;
    helperRef-&gt;complexA.realp = (Float32*) malloc(nOver2*sizeof(Float32) );
    helperRef-&gt;complexA.imagp = (Float32*) malloc(nOver2*sizeof(Float32) );

    helperRef-&gt;outFFTData = (Float32 *) malloc(nOver2*sizeof(Float32) );
    memset(helperRef-&gt;outFFTData, 0, nOver2*sizeof(Float32) );

    helperRef-&gt;invertedCheckData = (Float32*) malloc(numberOfSamples*sizeof(Float32) );

    return  helperRef;
}
</code></pre>

<p>//pass initialized FFTHelperRef, data and data size here. Return FFT data with numSamples/2 size.</p>

<pre><code>Float32 * computeFFT(FFTHelperRef *fftHelperRef, Float32 *timeDomainData, long numSamples) {
    vDSP_Length log2n = log2f(numSamples);
    Float32 mFFTNormFactor = 1.0/(2*numSamples);

    //Convert float array of reals samples to COMPLEX_SPLIT array A
    vDSP_ctoz((COMPLEX*)timeDomainData, 2, &amp;(fftHelperRef-&gt;complexA), 1, numSamples/2);

    //Perform FFT using fftSetup and A
    //Results are returned in A
    vDSP_fft_zrip(fftHelperRef-&gt;fftSetup, &amp;(fftHelperRef-&gt;complexA), 1, log2n, FFT_FORWARD);

    //scale fft 
    vDSP_vsmul(fftHelperRef-&gt;complexA.realp, 1, &amp;mFFTNormFactor, fftHelperRef-&gt;complexA.realp, 1, numSamples/2);
    vDSP_vsmul(fftHelperRef-&gt;complexA.imagp, 1, &amp;mFFTNormFactor, fftHelperRef-&gt;complexA.imagp, 1, numSamples/2);

    vDSP_zvmags(&amp;(fftHelperRef-&gt;complexA), 1, fftHelperRef-&gt;outFFTData, 1, numSamples/2);

    //to check everything =============================
    vDSP_fft_zrip(fftHelperRef-&gt;fftSetup, &amp;(fftHelperRef-&gt;complexA), 1, log2n, FFT_INVERSE);
    vDSP_ztoc( &amp;(fftHelperRef-&gt;complexA), 1, (COMPLEX *) fftHelperRef-&gt;invertedCheckData , 2, numSamples/2);
    //=================================================    

    return fftHelperRef-&gt;outFFTData;
}
</code></pre>

<p>Use it like this:</p>

<ol>
<li><p>Initialize it: <strong>FFTHelperCreate(TimeDomainDataLenght);</strong></p></li>
<li><p>Pass Float32 time domain data, get frequency domain data on return: <strong>Float32 *fftData = computeFFT(fftHelper, buffer, frameSize);</strong></p></li>
</ol>

<p>Now you have an array where indexes=frequencies, values=magnitude (squared magnitudes?).
According to <a href="http://en.wikipedia.org/wiki/Nyquist_rate" rel="nofollow noreferrer">Nyquist theorem</a> your maximum possible frequency in that array is half of your sample rate. That is if your sample rate = 44100, maximum frequency you can encode is 22050 Hz. </p>

<p>So go find that Nyquist max frequency for your sample rate: <strong>const Float32 NyquistMaxFreq = SAMPLE_RATE/2.0;</strong></p>

<p>Finding Hz is easy: <strong>Float32 hz = ((Float32)someIndex / (Float32)fftDataSize) * NyquistMaxFreq;</strong>
(fftDataSize = frameSize/2.0)</p>

<p>This works for me. If I generate specific frequency in Audacity and play it - this code detects the right one (the strongest one, you also need to find max in fftData to do this).</p>

<p>(there's still a little mismatch in about 1-2%. not sure why this happens. If someone can explain me why - that would be much appreciated.)</p>

<p><strong>EDIT:</strong> </p>

<p>That mismatch happens because pieces I use to FFT are too small. Using larger chunks of time domain data (16384 frames) solves the problem. 
This questions explains it:
<a href="https://stackoverflow.com/questions/9477535/unable-to-get-correct-frequency-value-on-iphone">Unable to get correct frequency value on iphone</a></p>

<p><strong>EDIT:</strong> 
Here is the example project: <a href="https://github.com/krafter/DetectingAudioFrequency" rel="nofollow noreferrer">https://github.com/krafter/DetectingAudioFrequency</a></p>

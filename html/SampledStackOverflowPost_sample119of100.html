<p>Here is a definition of a non-blocking algorithm: <a href="http://en.wikipedia.org/wiki/Non-blocking_algorithm" rel="nofollow">http://en.wikipedia.org/wiki/Non-blocking_algorithm</a>.</p>

<p>A pseudo code of a non-blocking solution to this problem:</p>

<pre><code># The number of forks.
FORKS_COUNT = ... 

# Indicates if the i-th fork is taken or not.
taken = new bool[FORKS_COUNT] 

# The philosopherId is a position at the table.
def haveDinner(philosopherId):
    leftFork = philosopherId
    rightFork = (philosopherId + 1) % FORKS_COUNT
    if leftFork &gt; rightFork:
        swap(leftFork, rightFork)
    while true:
        # Tries to take the left fork.
        while not compare_and_swap(taken[leftFork], false, true):
            # Do nothing.
        # Tries to take the right fork.
        while not compare_and_swap(taken[rightFork], false, true):
            # Do nothing.
        # Eats.
        ...
        # Returns the forks to the table.
        compare_and_swap(taken[leftFork], true, false)
        compare_and_swap(taken[rigthFork], true, false)
</code></pre>

<p>This solution uses the <a href="http://en.wikipedia.org/wiki/Compare-and-swap" rel="nofollow">compare-and-swap</a> idiom.</p>

Answered posted on: 2013-03-05 22:00:30+00:00
<a<p>The problem is here:</p>

<pre><code>s=s*2;
</code></pre>

<p>(Though you should be sure to <em>always</em> initialize your variables, e.g. <code>s=0</code> before the loop.)</p>

<p>Integers don't have a special value for when the number gets larger than the storage type, so they ***<a href="https://en.wikipedia.org/wiki/Integer_overflow" rel="nofollow">overflow</a>.</p>

<p>Here's an example of that could happen. Imagine that we store integers as a series of 4 bits where the first bit means that a number is negative. If we then begin counting in our system, we get the following:</p>

<pre><code>0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = -0
1001 = -1
1010 = -2
</code></pre>

<p>So you can see that the numbers keep on growing inside the computer, but what they translate to suddenly becomes negative when the most significant bit is flipped on.</p>

<p>Computers use all kinds of different schemes for storing negative numbers, but ***<a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow">Two's Complement</a> is common. It's more clever than the system I've used to explain things here, but the essential point remains the same: when numbers get too big they become negative. In the case of an <code>int</code> the cross-over point is often when you hit <code>2^31</code>, or 2147483648.</p>

<p>A workaround is to use <code>unsigned int</code>, which roughly doubles the largest number you can represent, or <code>long</code>, <code>long long</code>, <code>unsigned long</code>, or <code>unsigned long long</code>. Remember, this won't solve your problem, it will just give you larger numbers you can work with before a problem appears.</p>

<p>You can find the largest usable value using the <a href="http://www.cplusplus.com/reference/climits/" rel="nofollow"><code>limits.h</code></a> header file; for an <code>int</code> it is <code>INT_MAX</code>.</

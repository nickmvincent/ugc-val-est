<a<p>Writing transaction synchronization code is hard and will fail as soon as you start deploying the application to multiple servers. To resolve the issue use the proper ***<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)" rel="nofollow">isolation level</a> for the transaction</p>

<p>First of all remove all the transaction and session management code and syncronized stuff as you don't need it. Next simply annotate your method with <code>@Transactional(isolation=SERIALIZABLE)</code> to have locking on the database level, which will work regardless the number of application servers you have.</p>

<pre><code>@Transactional(isolation=SERIALIZABLE, rollbackFor = Exception.class)
public String addRequest(String actionCode) throws Exception {

    Session session = dao.getCurrentSession();
    System.out.println("start");

    certRequest
                .setRequestNbr(generateRequestNumber(certInsuranceRequestAddRq
                        .getAccountInfo().getAccountNumberId()));
    reqId = Utils.getUniqueId();
    certRequest.setRequestId(reqId);

    ItemIdInfo itemIdInfo = new ItemIdInfo();

    itemIdInfo.setInsurerId(certRequest.getRequestId());

    certRequest.setItemIdInfo(itemIdInfo);

    Serializable it = session.save(certRequest);
    if (it != null) {
            addAccountRel();
            System.out.println("\n \n Transaction value is as " + it);
            System.out.println("\n \n Refresh value is "
                    + generateRequestNumber(certInsuranceRequestAddRq
                            .getAccountInfo().getAccountNumberId()));
    }
    System.out.println("end1");
    return reqId;
}
</code></pre>

<p>To me it also looks like your code is flawed, as it looks like <code>reqId</code> and <code>certRequest</code> are instance variables, I don't see them passed into the method. For some reason it also looks wrong to me that you are generating a <code>requestNumber</code> twice, once outside and once inside the <code>if</code> statement.

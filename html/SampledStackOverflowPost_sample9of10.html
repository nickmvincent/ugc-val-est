<a<p>You shouldn't use (tail) recursion, as Common Lisp has no ***<a href="https://en.wikipedia.org/wiki/Tail_call" rel="nofollow">tail call optimization</a> guarantee.   Use <code>do</code> or <code>loop</code> instead, or even <code>prog</code> with <code>go</code>. </p>

<p>And algorithmically, <strong><em>always</em></strong> test your potential divisors in <strong><em>increasing</em></strong> order, starting from <em>2</em>, and stop when you exceed <strong><em><code>(sqrt n)</code></em></strong>:</p>

<pre><code>(defun ISPRIME (n) 
  (prog ((d 2))                          ; defines implicit block named NIL
    LOOP
      (if (&gt; (* d d) n)
           ( return-from ISPRIME t ))    ; (return T) also works
      (if (= (mod n d) 0)
           ( return-from ISPRIME nil ))  ; or just (return) 
      (if (= d 2)
        (incf d 1)
        (incf d 2))
      (go LOOP)))
</code></pre>

<p><code>(return)</code> is the same as <code>(return nil)</code>, and <code>(return val)</code> is the same as <code>(return-from NIL val)</code>. Since <code>prog</code> defines an implicit block named <code>NIL</code>, shorter, and more general, calls to <code>return</code> can be used there instead.</p>

<p>A fun way to pursue here is to use an extendable <em>list of primes</em> created by filtering an increasing numbers supply with this <code>isprime</code> function, to be used as divisors supply in another <code>isprime-p</code> function which would only test its argument by these primes, and not all odds, thus achieving another algorithmic performance gain. The primes list should be extended as needed. The primes would only go  upto the square root of the number being tested, and the primes themselves would only need to be tested by numbers upto the square root of the top prime (so, fourth root of the number being tested).

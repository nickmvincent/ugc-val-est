Answered posted on: 2011-09-27 18:13:27+00:00
<a<p>I think you'd be better served by a diagram... let's play with ASCII art!</p>

<p>A deque is usually an array of memory chunks, but all apart the front and back memory chunks are full. This is necessary because a deque is a RandomAccessContainer, and to get O(1) access to any container, you cannot have an unbounded number of containers from which to read the size:</p>

<pre><code>bool size() const { return first.size + (buckets.size()- 2) * SIZE + last.size; }

T&amp; operator[](size_t i) {
  if (i &lt; first.size) { return first[SIZE - i]; }

  size_t const correctedIndex = i - first.size;
  return buckets[correctedIndex / SIZE][correctedIndex % SIZE];
}
</code></pre>

<p>Those operations are O(1) because of the multiplication/division!</p>

<p>In my example, I'll suppose that a memory chunk is full when it contains 8 elements. In practice, nobody said the size should be fixed, just that all inner buckets shall have the same size.</p>

<pre><code> // Deque
 0:       ++
 1: ++++++++
 2: ++++++++
 3: ++++++++
 4: +++++
</code></pre>

<p>Now say that we want to insert at index 13. It falls somewhere in the bucket labelled 2. There are several strategies we can think about:</p>

<ul>
<li>extend bucket 2 (only)</li>
<li>introduce a new bucket either before or after 2 and shuffle only a few elements</li>
</ul>

<p>But those two strategies would violate the invariant that all "inner" buckets have the same number of elements.</p>

<p>Therefore we are left with shuffling the elements around, either toward the beginning or the end (whichever is cheaper), in our case:</p>

<pre><code> // Deque
 0:      +++
 1: ++++++++
 2: +O++++++
 3: ++++++++
 4: +++++
</code></pre>

<p><em>Note how bucket 0 grew.</em></p>

<p>This shuffle implies that, in the worst case, you'll move half the elements: O(N/2).</p>

<p><code>deque</code> has O(1) insert at either the beginning or the end though, because there it's just a matter of adding the element in the right place or (if the bucket is full) creating a new bucket.</p>

<p>There are other containers that have better insert/erase behavior at random indices, based on ***<a href="http://en.wikipedia.org/wiki/B+_tree" rel="nofollow">B+ Trees</a>. In an indexed B+ Tree you can, instead of a "key" (or in parallel) maintain internally a count of the elements prior to a certain position. There are various technics to do this efficiently. At the end you get a container with:</p>

<ul>
<li>O(1): empty, size</li>
<li>O(log N): at, insert, erase</li>
</ul>

<p>You can check the <a href="http://pypi.python.org/pypi/blist/" rel="nofollow"><code>blist</code></a> module in Python which implements a Python list-like element backed by such a structure.</

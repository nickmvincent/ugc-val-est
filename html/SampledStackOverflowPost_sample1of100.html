Answered posted on: 2012-10-06 00:44:23+00:00
<a<p>It isn't bad practice for domain object to request data they need, however it is usually considered bad practice to inject a repository dependencies directly into entities. One reason for this is that now your domain objects become part of a dependency graph which is a needless complexity. Furthermore, a repository typically carries with it ambient dependencies such as transactions and a unit of work. This adds complexity and makes reasoning about domain logic more difficult. </p>

<p>Instead, as specified by Sebastian Good, it is best to have application services provide the data that an entity needs. An application service is a great place to inject repositories and other <a href="http://martinfowler.com/eaaCatalog/gateway.html" rel="nofollow noreferrer">gateways</a>. The application service can provide not only data, but a mechanism for retrieving data as well, in cases where it is better to place logic for determining the exact instance of data needed in the domain. For an example, take a look at this <a href="https://stackoverflow.com/questions/12677396/domain-driven-design-services-and-validations/12679271#12679271">question</a>. So if a specific behavior requires access to some service, have the application service provide an abstraction of that service as an argument to the corresponding behavior method. This way, the dependency upon the service is explicitly stated in the method signature.</p>

<p><strong>UPDATE</strong></p>

<p>1ab) Yes that is correct. Another option is to use a lambda instead of <code>OrdersSelectorService</code>. If lambdas aren't available in your language then it should be an interface. The benefit over passing <code>OrderRepository</code> is based on the ***<a href="http://en.wikipedia.org/wiki/Interface_segregation_principle" rel="nofollow noreferrer">interface segregation principle</a> the goal of which is to reduce needless coupling. It is unlikely that a behavior on Customer needs all the methods on OrderRepository, instead it needs a specific function, so make that explicit.</p>

<p>2a) Yes, the behavior I'm referring to is a behavior on the <code>Customer</code> entity, which is just one of the methods on the class.</p>

<p>2b) Yes for reasons stated in 1ab.</p>

<p>2c) No, <strong>C</strong> should just be an interface that contains the required method. The service <strong>S</strong> could either implement that interface, or an implementation could be provided on the fly.</p>

<p>2d) Yes. This is the part of the argument favoring dependency injection over service location. A benefit of declaring the dependency in the method signature as opposed to the constructor of the class itself is because that service is typically needed for only a single method and it is wasteful to make it an member of the class. Another benefit is that your domain class doesn't need to be part of dependency graph from IoC container - makes things simpler.</p>

<p>3) I would call both dependency injection (DI). DI is meant to contrast service location wherein the class constructor or method would be responsible for obtaining required services via service locator.</p>

<p><strong>UPDATE 2</strong></p>

<p>1) Here's a C# code sample:</p>

<pre><code>// this is is the repository, but it doesn't have to be an interface, just some class encapsulating data access
interface IOrderRepository
{
  Order Get(string id);
  void Add(Order order);
  IEnumerable&lt;Order&gt; GetOrdersBySomeCriteria(SomeCriteria criteria);
}

class Customer
{
   // the selector parameter is a lambda.
   public string InterestedWhatOtherCustomerOrdered(Func&lt;SomeCriteria, IEnumerable&lt;Order&gt;&gt; selector)
   {
      // do stuff with selector lambda
   }
}

// this is the app service
class CustomerApplicationService
{
  readonly IOrderRepository orderRepository;

  public void DoSomething()
  {
     var customer = this.customerRepository.Get ...;

     // the app service passes lambda which in turn points to repository.
     var result = customer.InterestedWhatOtherCustomerOrdered(criteria =&gt; this.orderRepository.GetOrdersBySomeCriteria(criteria));

  }
}
</code></pre>

<p>This does not violate persistence ignorance and is very decoupled. The lambda parameter on the <code>InterestedWhatOtherCustomerOrdered</code> method specifies exactly what the method needs - nothing less nothing more. And it doesn't care how that functionality is provided, just that it is.</p>

<p>2) In the case of a lamda, C doesn't really exist anywhere because it is specified in its entirety by the lambda. If however you were to use an interface, for example <code>IOrderSelector</code>, that interface needs to be declared where the Customer aggregate exists. It could be implemented directly by the <code>OrderRepository</code>, or you could have an ***<a href="http://en.wikipedia.org/wiki/Adapter_pattern" rel="nofollow noreferrer">adapter</a> class.</p>

<p>3) The reason I mention IoC is because another approach would be to declare the dependency on an order selector in the constructor of the <code>Customer</code> class. Then, whenever a new instance of the class is created, that dependency (the order selector) would need to be injected. One way to do that would be to use an IoC container in places where the <code>Customer</code> class is instantiated. The reason this is problematic is because now you have to make sure to have access to the IoC container wherever you instantiate the <code>Customer</code> class. It is also a misalignment of responsibility, since creating a customer has nothing to do with an order selector, only one behavior needs it.</p>

<p>4) It is a difference of philosophy I suppose. I don't like to have domain objects reference repositories for reasons stated above and other reasons as well. Overall, it is typically frowned upon if you browser around SO or blogs, etc. It is true that repository interfaces are declared in the domain, but it doesn't mean that they should be referenced from domain entities directly.</
